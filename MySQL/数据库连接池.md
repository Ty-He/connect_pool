# 1 数据库连接池概述

* 含义：有多个**数据库连接**，把它们放到一个池子里，类似线程池

* 避免频繁的数据库连接的创建和销毁，提高程序的效率

一般来说，对于数据库操作都是在访问数据库的时候创建连接，访问完毕断开连接

但如果在高并发情况下，有些需要频繁处理的操作就会消耗很多资源和时间：

    1. 建立通信连接的TCP三次握手

    2. 数据库服务器的连接认证

    3. 数据库服务器关闭连接时的资源回收

    4. 断开通信连接的TCP四次挥手

* 涉及的知识点：
  * C++11新特性
    * 多线程/线程同步
    * std::chrono
    * 条件变量
    * 智能指针
    * Lambda表达式
    * =delete 删除函数(**单例模式**的类有些函数不允许存在)

  * 其它
    * MySQL数据库编程
    * 单例模式
    * STL
    * 生产者和消费者模型
    * Jsoncpp库的使用(解析配置文件中数据库相关信息)


# 2 MySQL API的使用

## 2.1 连接数据库的步骤

在程序中连接MySQL服务器，主要分为以下几个步骤：

    1.初始化连接环境

    2.连接MySQL的服务器，需要提供以下连接数据：

        * 服务器的IP地址
        * 服务器监听的端口(默认是3306)
        * 连接服务器使用的用户名(默认是root)和对应的密码
        * 需要操作的数据库的名字

    3.连接建立后，就是对数据库数据的添删改查

    4.如果进行数据 添加/删除/更新，需要进行事务的处理

    5.数据库的读操作 -> 查询 -> 得到结果集

    6.遍历结果集 -> 得到要查询的数据

    7.释放资源


## 2.2 MySQL C API

* 初始化连接环境

```
    // 参数：mysql->null
    // 返回值：分配初始化新对象，并返回改对象
    MYSQL *mysql_init(MYSQL *mysql);
```

* 连接MySQL服务器

```
/* 
返回值：
    调用成功，返回使用的数据库地址，即与第一个参数值相等
    调用失败，返回NULL
*/
    MYSQL *mysql_real_connect(
        MYSQL *mysql,
        const char *host,               // mysql服务器主机ip
        const char *user,
        const char *passwd,
        const char *db,                 // 要使用的数据库名字
        unsigned int port,              // 若为0，即3306
        const char *unix_socket,        // 本地套接字，不使用指定为NULL
        unsigned long client_flag       // 通常指定为0
    );
```

win下查看ip地址可以通过终端命令`ipconfig`来查看，这里本机的IP为`192.168.100.244`

若host参数被指定为`localhost`或`NULL`则认为是本地主机IP地址

* 执行sql语句

```
    // 执行一个sql语句，添删查改都可以
    int mysql_query(MYSQL *mysql, const char *query);
    /*
    参数：
        -mysql：数据库地址
        -querty：一个可以执行的sql语句
    返回值：
        查询成功，返回0，如果是查询，结果集在MySQL对象中
        出现错误，返回非0值
    */
```

// query : 查询...

* 获得结果集

```
    // 调用这个函数将结果集从服务器端取出
    // 结果集存储都MYSQL_RES对应的内存，调用失败返回NULL
    MYSQL_RES *mysql_store_result(MYSQL *mysql);
```

如果不调用这个函数，查询的结果会再服务器端保存

结果集中的数据是有**多行多列**(相当于一个二维数组)的，不能直接取出

每一行对应一条记录，每一列是创建的字段，所有字段叫表

* 获得结果集的列数
```
    // 列数，即字段的个数
    unsigned int mysql_num_fields(MYSQL_RES *result);
```

* 获得表头/列名/字段名
```
    MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result);
    // 返回一个结构体数组，对应名字在name成员中
    // 通过这个函数得到结果集中所有列的名字
```


```
    MYSOL_FIELD* fields = mysql_fetch_fields(res);
    int num = mysql_num_fields(res);
    for(int i = 0; i < num; ++i)
    {
        printf("当前列的名字：%s\n", fields[i].name);
    }
```

* 得到结果集中字段的长度

```
    //返回结果集内当前行的列的长度
    unsigned long *mysql_fetch_legths(MYSQL_RES *result);
```

这个函数主要是为了防止字符串中出现`\0`导致忽略后续值

返回一个整型的数组

```
    MYSQL_ROW row;
    unsigned long* length;
    unsigned inf num_field;

    row = mysql_fetch_row(result); // 取出记录
    if(row) 
    {
        num_field = mysql_num_field(result); // 得到字段个数
        length = mysql_fetch_length(result); 
        for(int i = 0; i < num_field; i++)
        {
            printf("column %u is %lu bytes in length.\n", i, legth[i]);
        }
    }
```

* 遍历结果集

```
    typedef char** MYSQL_ROW; // 指向一个char*类型的指针数组

    // 取出结果集中的一条记录
    MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);
```

第一次调用，取出第一条记录，第二次调用，取出第二条记录，以此类推...

如果记录取完了，则返回NULL.

* 资源回收

```
    // 释放本地保存的结果集
    void mysql_free_result(MYSQL_RES *result);

    // 关闭MySQL实例
    void mysql_close(MYSQL *mysql);
```

* 字符编码

```
    // 获得当前数据库使用的字符集
    const char *mysql_character_set_name(MYSQL *mysql);

    // 设置当前数据库使用的字符集 utf8
    int mysql_set_character_set(MYSQL *mysql, char *csname);
```

* 事务操作

不是每一个查询语句都要创建一个事务

创建事务的时机：要进行一系列逻辑处理的时候，这是一个完整的业务流程

在**流程开始**的时候创建一个事务，在流程结束时**判断**这一系列业务流程是否都执行成功了：

    如果都成功了，那么提交事务；否则进行数据回滚(回滚到创建事务的时机)

这样做是为了包装数据库中数据的正确性

```
    // mysql中默认会自动进行事务提交
    // 这样数据回滚时不一定回到最初的状态
    // 下面这个函数可以修改这个设置
    my_bool mysql_autocommit(MYSQL *mysql, my_bool mode);
    // mode == 1 启用自动提交； mode == 0 禁止自动提交
    // 函数调用成功返回0，失败返回非零

    // 事务提高
    my_bool mysql_commit(MYSQL *mysql);
    // 数据回滚
    my_bool mysql_rollback(MYSQL *mysql);
```

* 打印错误信息

```
    // 返回错误描述
    const char *mysql_error(MYSQL *mysql);
    // 返回错误号
    const char *mysql_errno(MYSQL *mysql);
```

* 其它
  * 需要的头文件 `<mysql.h>`
  * 以上API对应MySQL动态库
    * win: `libmysql.dll`
    * linux: `libmysqlclient.so`


这里需要有一些数据库的基础，再恶补一番后，继续推进进度：


# 3 MySQL API的封装

根据面向对象的思想，可以对官方提供的C-API进行封装，使它变得更加**好用**

手撸代码...

基于C—API的封装：`D:\code_cpp\test_23_9_1\ty_mysql`


# 4 数据库连接池的分析

数据库连接池主要用于网络通信的服务器端

网络通信时，服务器端有可能同时接收了多个客户端请求，并且客户端请求的数据并不在服务器上，

而是在服务器对应的**数据库服务器**上

网络通信的服务器有可能*部署了多个组件*，数据库服务器是其中一个

当服务器和数据库服务器频繁建立连接时，会非常浪费时间...

***

对应的解决方案就是使用**数据库连接池**

在数据库连接池中，需要事先和数据库服务器建立若干个连接，当进行通信时，服务器向连接池中取出一个可用连接

取出后，就可以和数据库进行通信了，通行完毕后，连接池与数据库的连接不用断开

而是服务器的对应的线程把数据库连接在还给连接池

如果数据库连接池是一个**单例模式**的类，就可以避免创建多个数据库连接池对象

* 创建一个单例模式的连接池类

* 连接池属性
  * ip
  * port
  * u + p
  * dbname
  * queue // 存储连接
  * max、min  // que 容量
  * time // 等待超时时长，规定存活时长

* 多线程/互斥锁

* 生产者消费者模型 
  * 消费者 --- 网络通信服务器端线程
  * 生产者 --- 实现数据库连接池提供的额外的线程(需检测连接池的连接数目)


# 5 实现数据库连接池

上面提到，连接池的类要设计为单例模式，这里补充以下单例模式相关知识：

关于单例模式的类有两种：
* 懒汉模式
  * 使用实例对象时才去创建它
* 饿汉模式
  * 不管用不用，只要类被定义出来了，这个实例对象也就有了

在winform入门中用到了一点点的单例模式就属于饿汉模式.

这里连接池的类设计使用**懒汉模式**

懒汉模式的实现：
    1. 使用静态局部变量(在c++11中是线程安全的)
    2. 使用互斥锁
    3. c++11 call_once

注意：
    连接池类普通构造函数要设置为私有，避免在外部创建对象

    然后提供公共静态方法，返回一个静态的连接池类对象，这个对象是线程安全的，且生命周期直至程序结束

    再次调用该函数，返回的是同一实例对象


    同时，要避免外部通过拷贝构造函数创建对象，这里需要设置权限或`=delete`直接删除

    还有，复制操作符重载的`=`删除掉

## 5.1 定义数据连接池

* 定义好连接池的各种属性

* 实现懒汉模式

## 5.2 添加和解析Json配置文件

连接池的属性不应该被写死，若写死，则只能连接指定的数据库

这里希望连接池类可以连接任意的数据库：

这就需要使用者将数据库的相关信息传递给程序--->**配置文件**(XML、JSON)

这里采用Json：

需要将以下数据写入JSON配置文件中：
```
{   
    std::string ip;
    std::string user
    std::string passwd;
    std::string dbname;
    unsingned short port;
    int min_sz;
    int max_sz;
    int timeout;
    int freetime;
}
```

存储到**JSON对象**中更合适一点，因为能同时指明某个变量是什么属性

对应9个键值对...

***

json文件写好后，就要给连接池提供一个解析(parse)json文件的方法，这里要用到`jsoncpp`库

这里要引入新的库，有必要重构一下cmake脚本文件...

* 补充一些CMake知识：
  * add_executable生成可执行程序的三种方式：
    * 1 分别添加.h头文件、.cpp文件、ui文件
    * 2 自定义查找格式写法
    * 3 自动查找资源文件写法

采用1就要手写文件名，2则是使用查找指令

这里介绍一个指令：`aux_source_directory`
    该指令会自动查找目录下有关C++的所有文件格式文件，如`.cpp、.cc`,但不会查找头文件

这个指令在之前的笔记中提到过...


## 5.3 单例类构造函数处理

调用解析函数加载配置文件，然后再构造函数内**创建数据库连接**

创建两个线程对象来**生产**连接和检测当前连接状态(是否**销毁**)

由于主线程有事要做，所以这两个线程对象不能调用`join()`阻塞线程，而是进行线程分离`detach()`

## 5.4 子线程任务函数的实现

注意记录数据库连接起始空闲时间点和计算存活总时长...

要用到`<chrono>`库操作时间

## 5.5 获取数据库连接和回收(给到使用者)

* 提供获取连接池保存的数据库连接的方法：

    * 当连接队列为空时，阻塞设定的时长，之后再次判断是否有可用连接，若没有，继续堵塞或返回空

    * 当有可用连接时，返回可用连接并从队列中弹出

* 当连接使用完之后考虑将连接归还给连接池

    * 提供回收资源的函数

    * 智能指针`shared_ptr`
  
这里不希望智能指针将它管理的对象析构掉，而是让内存回收，所以要手动指定`智能指针删除器`

使用智能指针是为了实现**资源管理**，而不是为了省去delete语句

也就是删除器不一定非要delete堆区内存，比如这里用到的删除器...

注意到数据库连接队列属于共享资源，在删除器内回收时要进行线程同步

## 5.5 数据库连接池的资源释放和互斥锁检查

* 释放堆内存
  
  * 数据库连接队列保存的指针

* 互斥锁的使用(线程同步)


# 6 补充

在vscode中使用vim，分屏操作不可能，当然vscode自动分屏

以下是几个可能用到的命令：

* 切换标签页

  * 向后切换 `gt`
  
  * 向前切换 `gT // 即 g shift t`
  
  * 进入函数 `gd`

* 行间移动
  
  * 将当前行移动至第一行    `zt`
  
  * 将当前行移动至中间行    `zz`
  
  * 将当前行移动至最后行    `zb`


